- Note: this is an experiment - please browse around and see what you might be interested in, and maybe we can discuss that! The document might be useful for reference later.
- Overview of Jupyter and ROS (Robot Operating System)
    - Looking at Project Jupyter is relevant to questions like:
        - What might a lab notebook look like?  What are some potential formats, and maybe some pitfalls?
        - What software is available for working with robots, machine learning, and data analysis tasks?
        - How can access to robots, data, and software be shared by a group  and accessible by them in a relatively secure way?
    - Looking at ROS is relevant to questions like:
        - What software is available to handle various aspects of what needs to happen to have functional robots with different hardware in different environments? 
        - What does existing software NOT do well? What's missing or painful?
        - For each build team leader, how do you see your build using/interacting with existing software?  Or conversely, what do you want to __avoid __doing with existing software?
            - This is something I have a rough answer for myself, but it turns out to be a hard (and at least to me, interesting) question.
    - A bit of history on the Jupyter Project - where did this come from, and where is it now? __Skip if you only care about the nuts and bolts of using the software itself.__
        - The project started as basically a souped up Python shell written by a graduate student named Fernando Pérez in 2001. That project is iPython. Fernando really liked the idea of interactive computing environments, and the project kept attracting contributors until it was widely used and had a lot of features. It wasn't at all clear early on that it would be the "winner" in this space.  They made the fateful (and good) decision to make the software's interface browser based in 2011.
            - http://blog.fperez.org/2012/01/ipython-notebook-historical.html
        - In 2015, there was enough interest that the project expanded into a more general set of open-standards, and services for interactive computing across multiple programming languages. And the project received a  large amount of academic and foundation funding up front through the newly-founded Berkeley Institute of Data Science (BIDS)!
            - https://news.berkeley.edu/2015/07/07/jupyter-project/
                - As an aside, Fernando joined UC Berkeley as an assistant professor and founded BIDS at the same time this happened. He received tenure last year - it's one of the few examples of a faculty member receiving tenure in large part for the work they've done on practical tools that support science.
        - Jupyter development continues to be funded partially through academic sources, however a lot the tools that have been developed to be used with it started out as internal tools at corporations, or were developed specifically to be able to interact with it.
            - The design decision early on by Project Jupyter to focus on specifications and APIs means that there are a huge number of tools that are designed to work with Jupyter.  
            - Some example tools
                - Converting a Jupyter notebook into an interactive web application (a dashboard)
                    - https://voila.readthedocs.io/en/stable/
                - Parametrized non-interactive notebook runs
                    - https://papermill.readthedocs.io/en/latest/
        - Academic use of Jupyter notebooks is extremely widespread. It's used by graduate students in many/most research areas that are related to working with scientific data, and also in machine learning and computer vision. It's also used clear down to the middle school level for introducing students to data science related topics. 
        - Industry use of Jupyter notebooks is widespread in Data Science and Machine Learning areas.  
            - As one example, Netflix uses them internally:
                - https://netflixtechblog.com/notebook-innovation-591ee3221233
            - And AWS, Google, and Microsoft now offer mostly-compatible services
                - Amazon Sagemaker uses Jupyter notebooks for ML:
                    - https://docs.aws.amazon.com/sagemaker/latest/dg/nbi.html
                - Google Colab is Jupyter notebooks hosted on Google infrastructure:
                    - https://colab.research.google.com/notebooks/intro.ipynb#scrollTo=GJBs_flRovLc
                - Microsoft Azure Machine Learning Studio has had Jupyter notebooks built in since 2015
                    - https://docs.microsoft.com/en-us/archive/blogs/machinelearning/introducing-jupyter-notebooks-in-azure-ml-studio
    - Jupyter Notebooks  are browser based interactive computing environments. What does that mean, and what are the details?
        - A definition of interactive computing
            - "Jupyter Notebook is an **interactive computing environment that mixes code, results of running the code in graphical form and documentation in one document**."
                - https://stribny.name/blog/2019/08/interactive-computing-with-jupyter-notebooks/
        - Jupyter supports many different languages.  A notebook runs a **__kernel__** and that kernel can have support for Python, MATLAB, Julia, R, or even interpreted C++.  Writing new kernels isn't hard - there's an API.
        - The fundamental element by which computation occurs is a **cell**. You don't normally run an entire notebook at once. Rather, you run one block of text in a particular programming language - a cell.
            - Output from running that cell is stored in the notebook below the cell, be it numeric, strings, or images.
            - "Magics" can be used to run code from different languages in cells.  
            - There's support for embedded LaTeX. 
            - Existing widgets can be used to create a graphical interface for tuning parameters on a computation. There's a good example of this later.
        - The cells in a notebook are running in a shared execution and data context because they are in the same kernel.  So, out of order execution of cells that modify the same variable is a known hazard!
            - This means that prior to putting a notebook into any kind of production use, you typically need to restart the kernel and run all cells in order to make sure behavior is deterministic.
            - I can demo the issue if anyone is interested.
        - The default IDE for accessing notebooks nowadays is JupyterLab. This runs in a browser window.  It's pretty basic but it works.
            - You can install JupyterLab on your computer. I'd recommend downloading and installing Anaconda Python for this purpose.
                - https://www.anaconda.com/products/individual
                - conda install -c conda-forge jupyterlab
        - JupyterHub is a web service for accessing Jupyter notebooks
            - It's a great multiuser environment, but it has limitations:
                - There's no collaborative editing, though that problem is being actively worked on - by a *specification* first:
                    - https://github.com/jupyterlab/rtc
                - There are commercial services that offer collaborative editing for Jupyter notebooks, but I certainly don't want to give them access to robots in my home network... 
                    - https://cocalc.com/doc/jupyter-notebook.html
            -  JupyterHub can be configured to use GitHub or Google Oauth for authentication, which is convenient.
            - There are many extension for interacting with other services such as schedulers (SLURM) and ROS (via JupyROS)
    - What do Jupyter notebooks enable, and what are they bad at?
        - It enables coding without having to know very much - there's a very low learning curve to get started.
            - At the same time, you can do some very interesting high level work with it.
        - It's **__great__** for rapid prototyping. 
        - It is good for working with Python libraries in data science and machine learning.
        - It is fairly commonly used in open science projects since it makes it easy to package the code, data, and display together. AND it creates an explorable interface - it's very easy to see what was published, and then modify the author's code to explore "what-if" scenarios. Are their conclusions correct? Can you come up with something they missed that is interesting.
        - The UI is not polished. It's kind of generic. So, if you need exquisitely beautiful UIs, this isn't for you.
        - It's not good for things like the final version of production code running on a server controlling a robot. Python code typically needs to be cleaned up a lot and exported out of the notebook as a coherent program for such production uses. 
        - A lot of projects that interact with (like the aforementioned Papermill) are kind of clunky.
    - **__I want to try this now without having to install anything!__**
        - There's a service for that.  Give MyBinder a GitHub URL for a conforming project and it will set you up to be able to run the Jupyter notebooks in that project in your browser. Here's a good link. Try running the default Lorenz Differential Equations playbook first to get a feel for things.
            - https://mybinder.org/v2/gh/jupyterlab/jupyterlab-demo/master?urlpath=lab/tree/demo
    - History of ROS project (__skip if you are more interested in nuts and bolts of the architecture__)
        - The ROS project was started by a company called Willow Garage in 2006. The founder was Scott Hassan (who wrote much of Google's original search engine code). 
            - He wanted to focus on standardizing as much as possible about robotics, and making it so that development could be on what's unique about a specific experiment rather than creating everything from scratch.
            - Over 7 years, Willow Garage developed ROS and hosted a total of around 200 interns (many from Stanford) who worked on the project.
            - The project would have continued at Willow Garage but Scott's interests changed, and he closed down Willow Garage.
            - However, there were already enough other companies and academics using the project that others stepped in and kept the project going.
            - There's a nice video documentary on at least part of this here:
                - https://www.redhat.com/en/open-source-stories/robots/breaking-the-wheel
        - Industry use: many robotics companies supporting it or providing services related to it; ConstructSim, Raputya, Google, AWS
    - What is ROS currently used for?
        - There's some hobbyist use as it is compatible with many "learner" robots.
        - There is a lot of academic use.  Many academic research robotics labs are using it in some capacity.  And the higher end teaching robots are almost all ROS compatible.
        - There's wide industry use.  There are a number of companies either supporting it or providing services related to it:
            - The Construct developed an online platform for learning robotics fundamentals. They use ROS and Gazebo for simulation of a number of different robots. They're used by universities, and I imagine that business has been good during the pandemic when universities wanted to keep normally in-person robotics courses going remotely:
                - https://www.theconstructsim.com/
            - AWS Robo Maker specifically uses ROS, and AWS is a contributor to ROSv2.
                - https://aws.amazon.com/robomaker/features/
            - Raputya Robotics provides services related to connecting distributed robots to each other, including encrypted traffic (which ROS v1 does **__not__** do):
                - https://www.rapyuta-robotics.com/
            - Google Cloud Robotics is a service that appears to have the actual robotics part of the software provided by ROS. It is pre-alpha and not well documented.
                - https://googlecloudrobotics.github.io/core/
    - What does ROS consist of?  Here, we are looking at ROS 1.  ROS 2 is different, more on that later.
        - There are 3 fundamental groupings of concepts related to the project (at least according to the software maintainers)
            - The filesystem level
                - Software is released as **packages** A package contain a manifest of what will become runtime processes; a software library that can interact with ROS; and things like datasets, configuration files, and other things necessary for the specific functionality that the package provides to work. The most granular thing that you can build and release is a package.
                    - Examples of packages:
                        - rosbridge_suite provides a JSON API to ROS functionality for non-ROS programs. I'm using it...
                            - http://wiki.ros.org/rosbridge_suite
                        - ros_control is still at least somewhat used for robot control. I may end up using it.
                            - http://wiki.ros.org/ros_control
                        - A listing of what someone considered useful ROS packages (mostly for debugging, like ros_wtf)
                            - https://ros.guru/2018/02/12/10-useful-ros-tools/
                    - Note that the build system for packages is significantly clunky...
                - Types of messages and descriptions of services are stored on disk...
            -  The computational graph level.  See http://wiki.ros.org/ROS/Concepts
                - **Nodes** are processes that perform computation.The granularity is not at the CPU level per se. Individual sensors, actuators, and functions like path planning would be nodes.  Nodes code is typically written in C++ or Python using libraries like roscpp or rospy. 
                - **Master** Individual nodes have to all be configured to know where the master is. It provides name look up and registration services. Actual communication between nodes is peer to peer and on random ports once they talk to the master to know how to find each other. This means the master isn't a bottleneck for communication. It also means that the ROS network is flat and can't have any real internal firewalls between nodes.
                - **Parameter server** This stores parameters for naming things in a global namespace (global in the context of a specific master). It's darn near a key-value store.
                - **Messages** "Nodes communicate with each other by passing messages. This is what I have working.  Messages have types, and the types need to match for a sender and receiver to be able to communicate.
                - **Topics ** Messages use a standard publish/subscribe methodology that "just works". A node publishes messages to a particular topic by name, and other nodes can subscribe to that topic by name. There can be many concurrent subscribers and publishers on a topic, there's no authentication, and the nodes likely don't know who the other nodes are. So this can potentially get very messy. 
                - **Services** Topics don't have good semantics for request / reply interactions Services fulfill this function. A node offers a service under a name and a client uses the service by sending the request message and awaiting the reply. 
                - **Bags ** can be used to store and play back message data. This might be useful for replaying messages in order to develop an algorithm.
            - The community level. In practice most development appears to have moved over to ROS 2, even as new distributions of ROS 1 have kept coming out. So what's here in practical terms is downloadable distributions:
                - http://wiki.ros.org/Distributions
                - Specific distributions are likely to only work on specific versions of Ubuntu.
                - Distributions have to be compiled from source on Raspian. This isn't fun unless you like to wait for a compiler to finish building dozens of packages on your Raspberry Pi while the battery on your robot is running down.
                    - The apparent solution is to use packaged distributions on Ubuntu. After I get stuff full working with Raspian (since I've already paid the price there), I'll move to Ubuntu 20.04
    - What kind of hardware can be worked with?
        - Pretty much anything with a general purpose CPU.
        - Microcontrollers, assuming you are using ROS 2
            - https://micro.ros.org/
        - FPGAs, assuming they can do publish/subscribe messages successfully. This is a ROS 1 thing... 
            - http://www.is.utsunomiya-u.ac.jp/pearlab/openreroc/en/3/10.html
            - ROS 2 is on its way. 
                - https://github.com/kubja/ros2-fpga
    - What are the points of friction with ROS 1? 
        - The original API design is fairly clunky - it's possible to get almost anything done, but it isn't necessarily easy. 
        - The build system is clunky.
        - By design, it is better at handling a single robot than robots coordinating.
        - It isn't good for realtime applications.
        - There's no real authentication, authorization, or encryption by default. Some other service (in my case, OpenVPN) has to be used to protect the network of robots.
    - What about ROS 2?
        - ROS 2 is a successor to ROS 1 that is a complete rewrite.  It is under very heavy development by a number of companies that contribute to different components.
            - When I checked, many of the repos had commits in the last few hours.
        - It uses DDS for a security layer, which is better than what ROS 1 does. Not having experience with it yet, I can't say more.
        - It can already work with hardware that ROS 1 can't yet work with.
        - It is going to have more realtime capabilities.
        - Unfortunately, as of now, the documentation not as thorough as ROS 1. Some people have posted their own articles as part of filling in the gaps on this:
            - https://medium.com/software-architecture-foundations/robot-operating-system-2-ros-2-architecture-731ef1867776
        - Hobbyist and academic use of ROS 2 is not as widespread as ROS 1.
            - Perhaps because many of the contributors are big companies?
        - It can communicate with ROS v1.
        - It has slightly different use cases that F'.  However, some projects combine ROS 2 and F':
            - https://www.genebm.com/drone-bytes/software-design/middlewares-ros-fprime
    - Here's an example of ROS in use in an academic context
        - Given a mathematical description of synchronization and swarming, program robots to do the same thing. The demo is done with ROS 1.
            - https://www.nature.com/articles/s41467-017-01190-3
            - https://www.youtube.com/watch?v=atLhROLzsFo

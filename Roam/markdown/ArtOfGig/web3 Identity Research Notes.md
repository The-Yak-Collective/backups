Research blockchain identity solutions and put together a presentation for the Yak Collective.
# Public Key Cryptography in web3
    - Web3 wallets are really just public/private keypairs — the same technology that underlies SSL/TLS, though the implementation looks more like PGP/GPG. All of the blockchains I’ve looked into use elliptic curve cryptography; Bitcoin and Ethereum both use the secp256k1 curve, while Solana uses Curve25519 (a.k.a. ed25519).
    - Most of the wallets we use today are “hierarchical deterministic wallets” (defined in BIP-0032 and refined in BIP-0043 and BIP-0044). Together, these standards define a chain of __six__ different private keys that ultimately derive the private keys of the actual wallets you use day-to-day from your “seed phrase” (public keys are derived when necessary from the private keys).
        - The seed phrase itself is a list of 12 – 24 words that encode a 128 – 256 bit random number + an appended 4 – 8 bit checksum.
        - This seed phrase is used to derive an “master” private key (`m`). Note that Solana uses a different “key phrase” (“ed25519 seed”) than Bitcoin and Ethereum (which both use “Bitcoin seed”).
        - The first node (“purpose”) is always `44` (for BIP-0044, indicating that this is a “multi-account” wallet) in the types of the types of uses we’re concerned with. The corresponding private key is derived in a fashion that prevents the “master” key from being compromised should this key be disclosed.
        - The next node specifies the “coin type”. Important values (for us) are 0 (Bitcoin), 60 (Ethereum), and 501 (Solana), though there are many, __many__ more. Again, the corresponding private key is derived in a fashion that prevents the key for the preceding node from being compromised should this key be disclosed.
        - The next node specifies the “account”. These are numbered sequentially starting at 0, and the keys are again derived in a fashion that prevents the “coin type” key from being compromised should this key be disclosed. It looks like the original intention was for this to represent the “identity” layer, but in practice everything (except Ledger devices) seems to set this to 0.
        - The next node is called the “change” node, and is either 0 (for externally-facing wallet nodes) or 1 (for internal-only wallet nodes). As far as I can tell, this is almost always 0 in practice (Bitcoin seems to use 1 in some cases). Note that this key is __not__ derived in a “hardened” way for Bitcoin and Ethereum implementations, and thus could compromise the “account” level if disclosed! (Solana __does__ derive the “change” node in a hardened fashion.)
        - An individual wallet __private__ key is derived, starting at 0. Note that this key is also not derived in a “hardened” fashion. The corresponding __public__ key is derived from the private key. __This is the functional identity layer of modern wallets.__
    - The steps above are called the “derivation path”. For Ethereum-related transactions this will almost always be `m/44'/60'/0'/0/n` (where `n` is the internal wallet node, starting at 0); most other systems seem to also follow this, only changing the `60'` bit to match the correct coin.
    - There’s also a second number called a “chain code” that is paired with each private key and is used to derive the keys in the next node down. The details are in BIP-0032, but aren’t important for the question of identity. Note that there’s also some variation in how different wallets handle the “coin type” and “account” nodes, though all of the big names (except for the Ledger hardware wallet, which has an eccentric and somewhat inconsistent — but arguably more secure for some applications — approach to the “account” level) handle things as described above. Be aware that some elliptic curve parameters __are__ used during intermediate key generation; as far as I can tell, Solana is consistent about swapping out ed25519 parameters for the secp256k1 parameters specified in BIP-0032.
    - MetaMask bundles all of this sensitive information together as a single “keyring” and (AES) encrypts it on disk using the user password.
    - The ultimate point of all of this is that the __private__ half of the keypair can “sign” data (in its simplest form, a signature is just the encrypted hash of the data being signed, though the different blockchains all put their own spin on this), while the __public__ half of the keypair can “verify” the signature data (decrypt the signature and verify that the payload matches the provided data). This interplay between public and private key is what handles __authentication__ in web3 (and similar technologies).
    - Wallet addresses constitute the most basic form of your public __identity__, and are what you see in MetaMask, Phantom, etc. These are not __quite__ the __public__ half of the corresponding wallet keypair:
        - Bitcoin addresses are either a version-prefixed, base58-encoded copy of the wallet public key (pre-2017) __or__ bech32-encoded string representing the public key’s hash (really, a hash of a hash) + a version prefix and a checksum suffix.
        - Ethereum addresses are the last 20 bytes of the the Keccak-256 hash of the public key, represented as 0x-prefixed hexidecimal.
        - Solana addresses are just the raw public keys, encoded using base58 (like older Bitcoin addresses).
    - Base58 encoding  uses 0 – 9, a – z, and A – Z, but excludes the “look-alike” characters 0, O, I, and l. Bech32 is just… kinda weird.
    - I have no idea why Bitcoin and Ethereum choose to use a hash of the public key rather than the public key itself. Some level of privacy, maybe? But the details of how signing works with elliptic curve cryptography (see the next section) mean that the public key can always be extracted from any transaction…
    - ## References
        - [HD Wallets and Derivation Paths: Explained](https://medium.com/myetherwallet/hd-wallets-and-derivation-paths-explained-865a643c7bf2)
        - [From Seed Phrase to Solana Address](https://www.abiraja.com/blog/from-seed-phrase-to-solana-address)
        - [BIP-0032 Hierarchical Deterministic Wallets](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)
        - [BIP-0043 Purpose Field for Deterministic Wallets](https://github.com/bitcoin/bips/blob/master/bip-0043.mediawiki)
        - [BIP-0044 Multi-Account Hierarchy for Deterministic Wallets](https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki)
        - [BIP-0039 Mnemonic code for generating deterministic keys](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki)
        - [SLIP-0044 Registered coin types for BIP-0044](https://github.com/satoshilabs/slips/blob/master/slip-0044.md)
        - [The Journey from Mnemonic (Secret Recovery Phrase) to Address](https://blog.mycrypto.com/the-journey-from-mnemonic-phrase-to-address)
        - [Elliptic Curve Cryptography (ECC)](https://cryptobook.nakov.com/asymmetric-key-ciphers/elliptic-curve-cryptography-ecc)
        - [How MetaMask🦊 stores your wallet secret?](https://www.wispwisp.com/index.php/2020/12/25/how-metamask-stores-your-wallet-secret/)
        - [Binary-to-text encoding](https://en.wikipedia.org/wiki/Binary-to-text_encoding)
        - [Why are there two bitcoin address formats?](https://medium.com/ballet-crypto/why-are-there-two-bitcoin-address-formats-8e33ab0982e8)
        - [Bech32](https://en.bitcoin.it/wiki/Bech32)
        - [What is an Ethereum Address?](https://info.etherscan.com/what-is-an-ethereum-address/)
        - [How are ethereum addresses generated?](https://ethereum.stackexchange.com/a/3619)
        - [Exchanging Encrypted Data on Blockchain Using MetaMask](https://betterprogramming.pub/exchanging-encrypted-data-on-blockchain-using-metamask-a2e65a9a896c)
# Signatures
    - Signatures prove that a particular action has been authorized by a particular wallet.
    - Public keys encrypt, private keys decrypt.
    - Private keys sign, public keys verify.
    - (Note the both keys can actually perform both functions, which is important for signing.)
    - We define “addition” on an elliptic curve curve using the following algorithm:
        - Draw a line between two points on the curve; this will always intersect the curve at one additional location. To add a point to itself, take the tangent line at that point; this will always intersect the curve at one additional location.
        - Reflect this additional point across the x-axis. This reflection is considered the “sum” of the two points being added together.
    - We use this definition of “addition” to in turn define “multiplication” by a scalar (note that the first step will always involve using a tangent line).
    - In elliptic curve cryptography, both the curve __and the initial point__, `P`, are standardized. We then solve for `Q = n × P`; `n` is our private key while `Q` is our public key.
    - Ethereum signatures use the Keccak-256 hashing algorithm, which is part of the superset of algorithms that SHA-3 belongs to. (Incidentally, the Keccak algorithm is also used for computing block hashes; the algorithm’s is designed to be highly tunable.) This is then encrypted using the wallet’s private key and combined with the wallet’s public key to form the final signature. Typically either the hash of a message or a JSON data structure (as defined in EIP-712) is signed; using a hash makes signature verification easier/faster for simple applications, but using EIP-712 allows wallets to present something actually meaningful to their users and to include things like nonces (which are important from a security perspective).
    - Thus, a signed message provides the following information:
        - The signer’s public key.
        - The signer’s wallet address (since this is derived from the public key).
        - Verification that the signer has interacted with (generally, “approved”) the data being signed.
    - __Signing does not require interaction with the blockchain.__ However, in order to be added to the global ledger (__signed__) messages need to be included in a mined block.
    - Signature validation consists of backing out the public key, using it to decrypt the hash, and then verifying that the hash corresponds to expected message. Generally, Ethereum seems to operate in a state similar to PGP “detached signatures” __without__ the original message, so hash verification involves reconstructing the original message.
    - ## References
        - [Signing and Verifying Ethereum Signatures](https://yos.io/2018/11/16/ethereum-signatures/)
        - [Elliptic Curve Cryptography (ECC)](https://cryptobook.nakov.com/asymmetric-key-ciphers/elliptic-curve-cryptography-ecc)
        - [Elliptic curve point multiplication (Wikipedia)](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication)
        - [How does one calculate the scalar multiplication on elliptic curves?](https://crypto.stackexchange.com/a/3908)
        - [What's the difference between SHA-256 and Keccak-256? Which one should be used on Ethereum for bitcoin like mining?](https://www.quora.com/Whats-the-difference-between-SHA-256-and-Keccak-256-Which-one-should-be-used-on-Ethereum-for-bitcoin-like-mining)
        - [SHA-3 (Wikipedia)](https://en.wikipedia.org/wiki/SHA-3)
        - [A Closer Look At Ethereum Signatures](https://hackernoon.com/a-closer-look-at-ethereum-signatures-5784c14abecc)
        - [Signing and Verifying Messages in Ethereum](https://programtheblockchain.com/posts/2018/02/17/signing-and-verifying-messages-in-ethereum/)
        - [Intro to Cryptography and Signatures in Ethereum](https://medium.com/immunefi/intro-to-cryptography-and-signatures-in-ethereum-2025b6a4a33d)
        - [EIP-712: Ethereum typed structured data hashing and signing](https://eips.ethereum.org/EIPS/eip-712)
# Authentication on web3
    - Website and dApp sign-ins on web3 are implemented using signing. There are currently 6 __different__ ways that an Ethereum wallet like MetaMask can sign data in this (non-transactional) context, which vary depending on __what__ data is being signed:
        - `eth_sign` — Sign __any__ hash. This means that it can be used to sign transaction data. Kept around for compatibility with some old dApps; MetaMask displays a warning when it is used.
        - `personal_sign` — Hash data is prefixed to prevent transaction signing (though this prefix has the side-effect of making such transactions expensive to verify on-chain). Can include additional UTF-8 encoded text (metaMask will display this). This is the only method supported by the Ledger and Trezor hardware wallets for signing non-transaction data.
        - `signTypedData`/`signTypedData_v1` — An implementation of an early draft of EIP-712, which is intended to provide the security affordances similar to `personal_sign` while being cheap to verify on-chain like `eth_sign` and at least modestly human-readable. (Note that `signTypedData` will eventually be set equal to whatever version corresponds to the adopted form of EIP-712.)
        - `signTypedData_v3` — An implementation of the current (*formal*) draft of EIP-712. MetaMask’s docs currently advise using this method.
        - `signTypedData_v4` — An implementation of the latest (__in-process__) draft of EIP-712. Supports arrays, but breaks struct encoding relative to `signTypedData_v3`.
    - Important parts of the various `signTypedData_v*` structures:
        - `domain` — This is a data structure that ties a signature to a particular website, dApp, smart contract, etc. It is This is specified directly as part of EIP-712 (though the object itself is described in the `domainSeparator` hash specification).
        - `chainId` — This ties a signature to a particular chain. Part of the `domain` object.
        - `name` — Human-meaningful description of the app requesting the signature. Part of the `domain` object.
        - `verifyingContract` — Smart contract address or URL. Part of the `domain` object.
        - `version` — Current version of the object being interacted with. Part of the `domain` object.
        - `message` — The __machine__-meaningful part of what’s being signed. Could just contain a hash (see above), but generally should be a __human__-meaningful data structure. This is specified directly as part of EIP-712.
    - Note that `signTypedData_v*` returns a hash of the `domain` hash (as `domainSeparator`) concatenated with a hash of the `message`. So again, shades of PGP detached signatures. The idea here is that `domainSeparator` is constant (for a given app version/chain) and `message` is either re-computable directly or with data stored elsewhere on-chain (presumably?). Reducing hash computation to a minimum is what makes `signTypedData_v*` more efficient than `personal_sign` (though if I understand this correctly, still less efficient than `eth_sign`).
    - (Somewhat cleverly, EIP-712 requires a definition of the parts of the message to be included __in__ the messages as `types`, with the `primaryType` key referencing the key in `types` that is used for `message`.)
    - So, if authenticating in web3 is just signing a data structure, and the key part of the data structure defined in EIP-712 is the `message` (if not using EIP-712 we’ll still get that message in an unstructured form if using `personal_sign`, or as a hash if using `eth_sign`)… Then what’s the content of `message`?
    - More-or-less, anything we want.
    - Because the point here — and why authentication __doesn’t__ require interacting with a blockchain __at all__ — is that we want to verify that the user controls the private key associated with the wallet they’re using to identify themselves. And we can do that verification using an Ethereum signing operation, since the returned signature __includes__ the associated __public__ key.
    - The only restriction we have is that whatever we want the user to sign needs to be __unique__ in order to prevent replay attacks. This can be accomplished by including a non-repeating, possibly randomly generated, number or UUID (a “nonce”), or even something as simple as a timestamp for when the `message` was generated.
    - For MetaMask, authentication can be initiated directly by the dApp, as MetaMask injects the `web3` library (which includes all of the required login/signing functions). (Note that __authentication__ is different than __connecting__ MetaMask to a dApp; the latter is only about exposing information such as wallet addresses to the dApp, and doesn’t actually require you to __prove__ anything about yourself. Authenticating and connecting to a dApp are different, and MetaMask only tracks __connections__ since __authentications__ don’t change MetaMask’s behavior w.r.t. the dApp.)
    - If you think this sounds a lot like certificate-based authentication in browsers (but using TOFU rather than PKI), then you’d be right! If you think that this sounds like how Gemini handles user authentication, but with the concept of a globally persistent identity, then you’d also be right! Using certificates for identity in web3 is __not__ a novel concept. What __is__ novel is the combination of a globally persistent identity with TOFU authentication. Essentially, the assumption underlying browser client certificates is that identities should be real and verified, the assumption underlying Gemini is that identities should be per-application (if not anonymous), while the assumption underlying web3 wallets is that identity is persistent but pseudonymous.
    - Anyways.
    - What if we don’t want to use MetaMask, or want to use a non-Ethereum-compatible blockchain? That’s where the WalletConnect protocol comes in.
    - WalletConnect adds a proxy “bridge server” between the dApp and the user’s wallet. The point of doing this is to remove the requirement for code injection in the browser; this allows mobile wallets to sign into desktop sessions, which provides an additional security boundary for the user’s web3 identity. The use of a bridge server thus makes the wallet-based authentication process more flexible and (in general) more secure (all messages stored in the bridge server are encrypted __and__ signed by the sender). It also allows for the use of push notifications, though wallets (and non-dApps) can just poll the bridge server or use it as a simple inbox.
    - The current version of the WalletConnect protocol is 1.0, and assumes an Ethereum-based wallet in a couple of places. It uses a symmetric key for encryption that is provided by the dApp and exposed to the wallet via the WalletConnect QR code or deep (application) link. Messages are EIP-712 data structures wrapped in JSON-RPC.
    - WalletConnect 2.0 removes Ethereum-isms in an attempt to be blockchain-agnostic, and vastly expands (and better specifies) the protocol specification. Some of this expansion is to remove reliance on EIP-712 (which means that there is now __some__ duplication between WalletConnect 2.0 and EIP-712), though the reliance on JSON-RPC data structures remain. From a security perspective, encryption keys and message “topics” are now negotiated between the dApp and the wallet and shielded from potential a potential attacker (even one who happens to be shoulder-surfing). WalletConnect also auto-expires sessions by default; a new “pairing” operation is used to regenerate shorter-lived sessions (including new pairing events, if needed… I __think__); this ensures that old interactions eventually expire, as do old connections (without the user having to manually remove them. (In this way, WalletConnect 2.0 also strikes a middle-ground between Web 1.0/2.0’s “everything all the time” approach and the radically scaled-back approach of initiatives like Project Gemini.)
    - ## References
        - [Signing Data (MetaMask Documentation)](https://docs.metamask.io/guide/signing-data.html)
        - [How to Authenticate with MetaMask (Moralis Documentation)](https://moralis.io/how-to-authenticate-with-metamask/)
        - [How to Connect Users with WalletConnect (Moralis Documentation)](https://moralis.io/how-to-connect-users-with-walletconnect/)
        - [EIP-712: Ethereum typed structured data hashing and signing](https://eips.ethereum.org/EIPS/eip-712)
        - [EIP712 is here: What to expect and how to use it](https://medium.com/metamask/eip712-is-coming-what-to-expect-and-how-to-use-it-bb92fd1a7a26)
        - [One-click Login with Blockchain: A MetaMask Tutorial](https://www.toptal.com/ethereum/one-click-login-flows-a-metamask-tutorial)
        - [Create A Simple Dapp (MetaMask Documentation)](https://docs.metamask.io/guide/create-dapp.htm)
        - [Writing for blockchain: wallet signature request messages](https://medium.com/hackernoon/writing-for-blockchain-wallet-signature-request-messages-6ede721160d5)
        - [Simply Put: How Does Certificate-Based Authentication Work?](https://woland.com/2014/03/03/how-does-certificate-based-authentication-actually-work/)
        - [Project Gemini Speculative specification](https://gemini.circumlunar.space/docs/specification.html)
        - [Technical Specification (WalletConnect 1.0 Documentation)](https://docs.walletconnect.com/tech-spec)
        - [Glossary (WalletConnect 2.0 Documentation)](https://docs.walletconnect.com/2.0/protocol/glossary)
        - [Technical Specification (WalletConnect 2.0 Documentation)](https://docs.walletconnect.com/2.0/protocol/tech-spec)
        - [Migrating from v1.0 (WalletConnect 2.0 Documentation)](https://docs.walletconnect.com/2.0/migration)
# Name Services & Multi-Signature Safes
    - Wallets by themselves are not particularly human-memorable, which is where DNS-like systems like the Ethereum Name Service (.eth) and Bonfida’s Solana Name Service (.sol) come in. These services can tie a wallet or smart contract address to a human-meaningful name.
    - Multi-signature “safes” such a Gnosis Safe can also be used for identity purposes. Using multiple wallets (for example, MetaMask + a hardware wallet) to control a single multi-sig safe can provide a higher level of security around identity, and can also allow identities to be handed off between individuals (or even groups of individuals).
    - It may make sense to think of tools like MetaMask as suitable for daily transactions and authentication, multi-sig safes like Gnosis for identity and assets, and hardware wallets like Ledger, Trezor, Keystone, etc. as essentially the equivalent of Yubikeys. (Maybe one day Yubico will make hardware wallets too; for now, the Trezor Model T seems closest to that dream, except that it doesn’t support iOS / connections over lightning.)
    - ## References
        - [ENS](https://ens.domains/)
        - [Solana Name Service](https://naming.bonfida.org/)
        - [Gnosis Safe](https://gnosis-safe.io/)
        - [MetaMask](https://metamask.io/)
        - [Ledger](https://www.ledger.com/)
        - [Trezor](https://trezor.io/)
        - [Keystone](https://keyst.one/)
        - [Yubico](https://www.yubico.com/)
# W3C Decentralized Identifiers (DIDs)
    DIDs take the concept of a cryptographic identity and wrap it into a new URL spec that resolves to a “document” (really, a data structure provided by __someone__) that formalizes concepts like that of the identity “controller” that are used in WalletConnect 2.0 (though it’s unclear to me which came first). DIDs allow the definition of cryptographic verification and authentication methods that align with how wallet-based identities operate.
    DIDs basically provides full-on (__potentially__ client-side) SSO-like functionality to any service that supports them: You enter your DID, the service issues an appropriate challenge, you (or a service provider specified as an authentication method) respond to that, and you’re in. It’s a generalized version of WalletConnect.
    Some other benefits:
        - A bridge between a world of wallet-based identities and the current world of centralized oracles. It’s important to note that there’s nothing within the DID spec that __requires__ the use of a blockchain — in fact, recall that wallet-based identities themselves don’t require a blockchain. DID resolution information could be attached to someone’s Google Account and an SSO provider like Okta could be used as an authentication provider, for example
        - It provides a way of managing a single identity across multiple devices. For a wallet-based identity to exist on multiple devices requires that private key associated with the wallet exist on each device — an approach which can significantly increase the attack surface. Moreover, if a wallet’s private key is compromised, so is the identity itself. A DID-based identity __can__ be cryptographically tied to multiple wallets (though not all proposed DID “methods” support this — for example, the ENS method simply maps ENS names to DIDs, and thus is tied to a single wallet address), allowing (though not __guaranteeing__) recovery should one of the wallets be lost or compromised. This same functionality allows for verification methods to be rotated proactively. DID-based identity would also allow for “custodial” identities, which makes them suitable for use as identifiers for children.
        - DIDs can be tied to W3C “verifiable credentials” by way of the embedded `assertionMethod`. This allows a DID to be linked to a government-issued credential, __but only if the DID controller chooses to do so__. It also allows the credential to be verified even if the issuing entity ceases to exist (assuming that the associated DID and DID document are written to something like a blockchain). (Basically, the verifiable credential contains signed data that can be verified using a public key or service listed as an `assertionMethod`. In order for this to work, the state of both the verifiable credential __and__ the `assertionMethod` need to be known at the time that the signature was made. In practice, this either means having a high degree of trust in the data integrity and time synchronization of the systems in question, or using a blockchain. Alternately, the party requesting verification could ask the DID holder — or a service acting on their behalf — to sign some data during verification in order to prove that they still control the corresponding private key.)
    Despite the fact that a service __can__ be used as an `assertionMethod` (though it remains unclear to me __how__), the spec goes out of its way to discourage this use. I suspect that the DID authors imagined blockchain-centric applications being dominant, with services being limited to governmental entities and centralized, high-security situations (which would combine the DID’s cryptographic features with other physical methods of verification). In practice, use of DIDs seems to either be strongly device-to-device centric — the idea is generally to establish an encrypted channel for transmitting other information. Since the use of service endpoints is discouraged, this means short-range device-to-device communications, or providing key material that can be cached (for example, a GPG key) and later applied to a method of communication that is established out-of-band (email)
    It’s worth noting that another way to solve the problem of managing and recovering a single identity across multiple wallets can also be solved using smart contracts like Gnosis safe. The advantage DIDs have over this approach is that they don’t require interacting with a blockchain in order to update a DID, unless the DID itself is stored on the blockchain. Also, by virtue of being __documents__ rather than __programs__, DIDs offer a smaller attack surface than something like Gnosis Safe.
    Despite theoretically not requiring blockchain, the majority of currently proposed DID “methods” use a blockchain as a __verifiable data registry__. (A DID method is to the DID specification as a URI scheme is to the URI specification… Except that the DID method defines not only a scheme but also a set of mechanisms for interacting with that scheme. So a little bit like the HTTP scheme __and__ protocol.) The DID specification seems to imply that service providers can be used as authentication methods (if defined by the registered method?)… But I’ve yet to see an example of this — current DID schemes seem to __require__ wallet-like functionality to work.
    The DID standard doesn’t require change notifications, but seems to acknowledge that this is a weakness in the spec.
    DID methods are not required to support verification method revocation. This is initially surprising until you recall that DIDs primarily come out of the wallet-as-identity paradigm… And there’s no way to revoke the private key of a wallet without destroying the wallet itself! This makes __controller__ rotation equivalent to verification rotation for wallet/blockchain-centric DIDs.
    The fact that controllers can be rotated and verification methods revoked means that the public keys included in a DID can only be used to trust signed data if the time of the signature __relative__ to the DID state changes can be determined. This basically requires that both the DID and the signed data be anchored in a blockchain for trustless systems; otherwise trust must be placed in the integrity (and time synchronization) of the databases holding these pieces of information. (As far as I can tell, this same problem applies to tying DIDs to verifiable credentials — either both items __must__ be anchored in a blockchain, or there needs to be certainty about the controller, verification method, __and__ verifiable credential states at the time the verifiable credential was signed.)
    (Note that the DID spec seems to require that the `versionId` or `versionTime` of the DID document be included in the proof/signature in order to ensure its validity in a trustless system, but then doesn’t expand on their use or even include them in the examples of signed verifiable credentials. And I can’t think __why__ these properties would be needed in a trustless system so long as we have DID document history and the document being verified is also anchored in a blockchain.)
    I’m also pretty sure that __either__ both the DID and verifiable credential need to be signed (each as a unit, including the “proof” in the verifiable credential) needs to be signed __or__ both the DID and verifiable credential need to live on a blockchain in order to prevent an attack where a forged DID and verifiable credential that are copies of the original with just a different DID string are presented as proof of physical identity.
    For DID recovery, the specification suggests a controller quorum method that is strongly reminiscent of multi-signature vaults.
    From section 9.12 (“Immutability”):
        - > For [DID methods](https://www.w3.org/TR/did-core/#dfn-did-methods) tied to a global source of truth, a direct, just-in-time lookup of the latest version of a [DID document](https://www.w3.org/TR/did-core/#dfn-did-documents) is always possible. However, it seems likely that layers of cache might eventually sit between a [DID resolver](https://www.w3.org/TR/did-core/#dfn-did-resolvers) and that source of truth. If they do, believing the attributes of an object in the [DID document](https://www.w3.org/TR/did-core/#dfn-did-documents) to have a given state when they are actually subtly different might invite exploits. This is particularly true if some lookups are of a full [DID document](https://www.w3.org/TR/did-core/#dfn-did-documents), and others are of partial data where the larger context is assumed.
    This is __exactly__ the sorts of concerns that Moxie Marlinspike voiced about the current blockchain ecosystem in January 2022; for DIDs to really work, individual devices badly need direct access to blockchain data (__without__ having to store the entire chain). The DID spec authors also explicitly acknowledge that cryptographic proof of control is actually a fairly weak standard; there’s an expectation here that DID methods used for critical applications will have additional __physical__ identity verifications in place. (This is probably one reason why, despite DIDs being strong associated with blockchains, the spec is written in a way as to be independent of them — when it comes to things like military or medical — or even, IMHO, __financial__ — applications, purely cryptographic proof-of-identity is probably too weak.)
    While it’s not explicitly stated, it’s strongly implied in some parts of the spec that DIDs are intended to be public, __unencrypted__ document references. At the same time, the spec acknowledges that this presents a correlation risk, and suggests using multiple, relationship-specific DIDs instead (which are somewhat confusingly called “pairwise DIDs”). Note that in this latter case it’s important that all DID document material (mostly verification methods, though importantly *not* service endpoints) also be unique to prevent indirect correlation attacks. The DID spec encourages the use of a __single__ service endpoint that is either fully generic or only references the DID `id` itself, assuming that service endpoints are necessary at all.
    The spec implies (albeit in a non-normative section) that `equivalentId` and `canonicalId` should use the same method as the DID’s `id`. Additionally, links to external documents should be protected as “hashlinks” (cryptographic hyperlinks) if they’re included at all. (It’s not clear to me how this requirement interacts with allowing services to provide verification methods…)
    Base58 encoding shows up __a lot__ in DID and related specifications. I’m starting to think that this may be the single greatest contribution that Bitcoin has made so far.
    Finally, it’s important to note that DIDs are intended for more than just people — for example, DIDs could refer to IoT devices or websites. The latter case is kind of interesting, because not only would it allow website URLs to be changed without breaking existing links, but you could also imagine sharing website public key material as part of the DID. This would basically remove the name for certificate authorities should the website DID document be stored on a blockchain (the implications with ENS are obvious!).
    This is all __very__ cypherpunk.
    So, who’s for DIDs?
        - Many blockchain/web3 companies
        - Microsoft (!!!)
    Who’s against DIDs?
        - Apple
        - Google
        - Mozilla (!!!)
    So, that’s some surprising alignments. Apple and Google both play a significant role as identity providers, and Apple is attempting to roll out a more centralized competitor to verifiable credentials, so this may be the origin of these objections. Mozilla seems to be fixated on the notion that blockchain technologies are driving CO₂ emissions. If the objections continue to stand, then the DID standard may be effectively dead. Even if Apple, Google, and Mozilla come to an agreement with the DID Working Group to pass the proposal as a standard, these three compnaies are really the __only__ browser creators out there; if they refuse to __implement__ the standard, then it will also be effectively dead.
    So, the future for DIDs looks bleak.
    ## References
        - [Decentralized Identifiers (DIDs) v1.0 (W3C Proposed Recommendation)](https://www.w3.org/TR/did-core/)
        - [DID Specification Registries (W3C Working Group Note)](https://www.w3.org/TR/did-spec-registries/)
        - [Verifiable Credentials Data Model v1.1 (W3C Recommendation)](https://www.w3.org/TR/vc-data-model/)
        - [My first impressions of web3](https://moxie.org/2022/01/07/web3-first-impressions.html)
        - [Cryptographic Hyperlinks](https://tools.ietf.org/html/draft-sporny-hashlink-05)
        - [Cypherpunk (Wikipedia)](https://en.wikipedia.org/wiki/Cypherpunk)
        - [Decentralized Identifiers (DIDs): A Beginners Guide!](https://tykn.tech/decentralized-identifiers-dids/)
        - [Microsoft’s Dream of Decentralized IDs Enters the Real World](https://www.wired.com/story/microsoft-decentralized-id-blockchain/)
        - [DID Formal Objection FAQ](https://w3c.github.io/did-wg/faqs/2021-formal-objections/)
# Future Directions
    - I ran out of time and did not do a particularly deep dive related to [ENS](https://ens.domains/) (.eth) and Bonfida’s [Solana Name Service](https://naming.bonfida.org/) (.sol). There are also other DNS-like constructs out there (.id, .btc, .crypto). It would be good to for there to be a more expansive overview of these services.
    - Gnosis Safe and other multi-signature smart contracts can be used as a form of collective identity. It would be great to deep-dive into how this works.
    - [Ceramic](https://ceramic.network/) is used to back a lot of __practical__ identity solutions on web3, such as storing “personal” data that’s linked to an ID. There’s even a Ceramic-specific DID proposal. It would be good to understand more about this protocol and its role within the web3 identity ecosystem.
    - There’s recently been some chatter about “soulbound NFTs” as a form of identity. It’s not clear to me yet what these are or what they bring to the table.
